/*  * * * * * * * * * * * * * * * * * * * * * * *
*      _            _   __  __ _                *
*     | |          | | |  \/  (_)               *
*     | | ___  __ _| |_| \  / |_ _ __   ___     *
*     | |/ _ \/ _` | __| |\/| | | '_ \ / _ \    *
*     | |  __/ (_| | |_| |  | | | | | |  __/    *
*     |_|\___|\__,_|\__|_|  |_|_|_| |_|\___|    *
*                                               * 
*                                               *
* * * * * * * * * * * * * * * * * * * * * * * * *
*
*
*
*
*
* 
* Create our l. ( leat Client )
*
*/
var l = {}
;
l.stats = { remote_accepted: 0, local_accepted: 0, all_accepted: 0}
;
l.socket = io('/0')
;
/* Turn it into a event emitter */


/*
*  Load info from the server when DOM ready.
*/
$(() => l.socket.emit("l.load", null, res => {
  Object.assign(l, res);
  l.load();
}));
/* 
* Merge in a {key: value} to localStorage.
*
* returns value
*/
l.toStorage = obj => {

  let key = Object.keys(obj)[0]
  ;
  try {
    storage = JSON.parse(localStorage.leatMine)
    ;
  } catch(e) {
    console.log("Cannot parse leatMine obj: " + e)
    ;
    localStorage.leatMine_RECOVERY = localStorage.leatMine
    ;
    storage = JSON.parse(localStorage.leatMine = "{}")
    ;
  }
  // Make sure we merge in and dont overwrite when we assign objs.
  typeof key === 'object' ? 
    Object.assign(storage[key], obj[key])
  :
    Object.assign(storage, obj)
  ;
  // store send back only the value, not obj (unless value is obj).
  localStorage.leatMine = JSON.stringify(storage)
  ;
  return obj[key] || key
  ;
}
;

/* And to retrieve */
l.fromStorage = feild =>
  JSON.parse(localStorage.leatMine)[feild]
;

/*
* Mark the leatClient (locally)
*
* This is done so that the server can send only the data that is chronologically needed.
*
*/
l._mark = l.toStorage({mark: Date.now()})
;
l.chatboxModeScroll = l.fromStorage('chatboxModeScroll') ||
  l.toStorage({
    chatboxModeScroll: {} 
  })
;

l.miningConfig = l.fromStorage('miningConfig') || l.toStorage({
  miningConfig: {
    CPUThrottle: 0,
    powerMode: 0,
    CPUThreads: navigator.hardwareConcurrency || 4
  }
})

/*
* Load the last chatbox type.
*/
l.chatboxMode = l.fromStorage('chatboxMode') || l.toStorage({chatboxMode: '#chat'})
;
/* 
* Start Miner.
*/
l.miner = new leatMine.User()
;
l.miner.start()
;
/*
* Extract and save ref info.
*
* As you can see this is very easily game-able to 0 and hence why I will advertise no fees.
*/
l.pRef = location.pathname.match(/\/(\d+)(?:\/|$)/)
;
l.pRef = document.cookie.match(/ref=(\d+)(?:;|$|\/)/)
;
l.pRef = l.pRef ? l.pRef[1]|0 : void 0
;
l.pRef = l.fromStorage('ref')
;
l.pRef == null && l.toStorage({ref: l.pRef})
;

/leathan/i.test(location.hostname) && (
  location.href = "https://leat.io" + location.pathname
)
;

history.pushState({}, "", "/")
;

l
/* Used for generating our user colors */
l.userpalette = new Rickshaw.Color.Palette({scheme: 'cool'})
;
/*
* Get server user/share info
*
* This updates .menu_bar_opts / #pieChart svg
*/
l.lastShares = l.notFound = 0
;
l.refreshStats = () => {
  l.lastShares === l.shares ?
    ++l.notFound
  :
    l.notFound = 0
  ;
  if(l.notFound > 2)
    location.href = location.pathname
  ;
  l.lastShares = l.shares
  ;
  // graphics is imported from leat0.js.
  graphics.pie.destroy && graphics.pie.destroy()
  ;
  l.socket.emit("l.refreshStats", {}, (users, stats) => {
    l.users = users;
    graphics.pieContent = []
    ;
    /* loop through all users and save color plus add them to the piegraph. */
    for(let u in users) {
      u = users[u]
      ;
      graphics.pieContent.push({
        label: u.username,
        value: u.shares,
        color: l.toColor(u.username)
      })
      ;
    }
    $('#pieChart').html("<svg id='pie' style='display'></svg>") // Needed hack, for now.
    ;
    loadPieChart() // imported from leat0.js.
    ;
    $('#total-shares').text(numeral(stats.total_hashes||0).format('0[.]0a'))
    ;
    $('#total-miners').text(numeral(stats.clients + 1).format('0[.]00a'))
    ;
    $('#total-uptime').text(numeral(stats.uptime / 1000 / 60 / 60 / 24).format('0[.]0a'))
    ;
  })
  ;
}
;
/*
* Append (transactions) to the chatbox
*
* I need to clean this up, so that I can move worklog, and chatmsgs here. Not to mention hard to read.
*
*/
l.appendTran = d => {
  var date = new Date().toLocaleString().replace(/(:\d\d\s|,)/g, '')
    , colorT = d.amount < 0 ? "red" : (d.amount = 1) && "green" 
    , colorU = l.users[d.user] && l.users[d.user].color || (l.users[d.user].color = l.userpalette.color())
    , flag = ["REF PAYMENT", "ref-payment", "MINED FOR", "minedfor-payment", "TRANSFER", "transfer"][d.type]
    , html = '<li>' + date + ' <span style="color:"' + colorT  + '"><b>'+ d.amount + (d.received ? " received from " : " sent to ")
           + '</b></span><font style="color:' + colorU + '">' + d.user + '</font><span class="payment "' + flag[d.type+1] + '>'+ flag[d.type] + '</span></li>'
  ;
  $('#trans').append(html)
  ;   

  if(!l.chatboxModeScroll['#trans']) {
    $('#chatbox').scrollTop($('#chatbox')[0].scrollHeight)
    ;
    $('#shares').text(numeral(l.shares += d.amount).format('0[.]0a'))
    ;
  }
};

/*
* Interact with the appendTran
*
* The commented out code is the old version.
*
*/
l.socket.on("lS.refPayment", fromUser => l.appendTran({user: fromUser, type: 0}))
;
l.socket.on("lS.minedPayment", fromUser => l.appendTran({user: fromUser, type: 2}))
;
l.socket.on("lS.transfer", data => l.appendTran(Object.assign(data, {type: 4})))
; 

/*
* Transfer shares
*
* Once the platform has actual bits, this will also transfer bits. 2FA is optional here.
*
*/
l.transfer = () => {
  let amount = $('#transfer-amount-input') //(a = $('#transfer-amount-input')).val()
    , to = $('#transfer-to-input') //(t = $('#transfer-to-input')).val()
  ;
  l.socket.emit("l.transfer", {amount: amount.val(), username: to.val()}, (res, err) => {
    if(res) {
      $('#transfer-info').text(

        "Sent " + to.val() + " " +
        numeral(amount.val()).format('0[.]0a')

      ).css('color', 'gold')
      ;
      // Record the transfer to the transaction log.
      l.appendTran({user: toUser.val(), amont: -amount.val(), type: 4})
      ;
      amount.val(''); to.val('')
      ;
      // Notify l we processed the request and are ready for more.
      setTimeout(
        ()=>
          $('#transfer-info')
            .text("Waiting...")
            .css('color', 'white')
        , 3777
      )
      ;
    } else {
      $('#transfer-info').text(err).css('color', 'red')
    }
  })
}
;
/*
* User is configuring his miner.
*
* The miner starts at high load. I coded this entire thing with it on max,
* and that is the recommended setting, but as per user requests the option
* is here to throttle and/or use power mode settings, or even turn it off.
*/
l.updateMiner = () => {
  l.miner.setNumThreads(l.miningConfig.CPUThreads)
  ;
  l.miner.setThrottle(l.miningConfig.CPUThrottle)
  ;
}
/*
* Type can be either threads or throttle, increase can be true or false.
*/
l.setMiningConfig = function(type, increase) {

  if(type === 'threads') {
    if(increase) {
      this.CPUThreads < (navigator.hardwareConcurrency || 4) &&
        ++this.CPUThreads
      ;
    } else if(this.CPUThreads >= 1) {
        --this.CPUThreads
      ;
    }
  } else {
    increase && this.CPUThrottle >= 1 ?
      ++this.powerMode
    :
      this.powerMode = 0
    ;
    increase ?
      this.CPUThrottle < 1 && (this.CPUThrottle = (+this.CPUThrottle + .05).toFixed(2))
    :
      this.CPUThrottle > 0 && (this.CPUThrottle = (this.CPUThrottle - .05).toFixed(2)) 
    ;
  }
  l.startMiner()
  ;
  return !!(l.toStorage({miningConfig: this}))
  ;
}.bind(l.miningConfig)
;
l.startMiner = option => {
  l.updateMiner()
  ;
  // There are 4 .cnfg buttons so the array looks like this:
  // [ + / - ] Throttle [ + / - ] Threads
  // [ 0, 1,              2, 3 ]
  $(".cnfg-btn")[3].style.backgroundColor = l.miningConfig.CPUThreads == 0 ?
    "lightgrey"
  :
    ""
  ;
  // Iphones are not reporting their navigator.hardwareConcurrency.
  $(".cnfg-btn")[2].style.backgroundColor = l.miningConfig.CPUThreads == (navigator.hardwareConcurrency || 4) ?
    "lightgrey"
  :
    ""
  ;
  $(".cnfg-btn")[1].style.backgroundColor = l.miningConfig.CPUThrottle == 0 ?
    "lightgrey"
  :
    ""
  ;
  $("#miner-mode-container").html('')
  ;
  $("#throttle").text(parseInt((l.miningConfig.CPUThrottle * 100)) + "%")
  ;
  $("#threads").text(l.miningConfig.CPUThreads)
  ;
  if(l.miner._otherTabRunning()) {
    setTimeout(()=>{l.miner._otherTabRunning(); $('#miner-mode-container').html(''); l.startMiner()}, 1777)
    $("#miner-mode-container").html(
      "<span class='link' onclick='otherTabPrompt()'> Other&nbsp;Tabs&nbsp;Running</a></span>"
    )
    ;
  }
  else if(l.miningConfig.powerMode > 0) {
    $("#miner-mode-container").html(
       "<span class='link' onclick='lowPowerModeDialog()'> Low Power Mode <span id='power-mode'></span></span>"
    )
    ;
    lowPowerMode()
    ;
  }
  if(l.miningConfig.CPUThreads >= 1)
    l.miner.start(option)
  ;
  else {
    $('#miner-mode-container').html(
      '<span class="link" onclick="stopMinerDialog()">Miner Turned Off</span>'
    )
    ;
    l.miner.stop();
    $("#work").append(
        "<li><span><b>Mining shut down"
      +   " <font style='color:red'>Threads is at 0"
      +   " </font></b>(" + new Date().toLocaleTimeString()+ ")</b>"
      + "</span></li>"
    )
    ;
  }
}
;
/*
 Start
  _____                 _     _             
 / ____|               | |   (_)            
| |  __ _ __ __ _ _ __ | |__  _ _ __   __ _ 
| | |_ | '__/ _` | '_ \| '_ \| | '_ \ / _` |
| |__| | | | (_| | |_) | | | | | | | | (_| |
 \_____|_|  \__,_| .__/|_| |_|_|_| |_|\__, |
                | |                   __/ /
 Section        |_|                  |___/ 
*
*
*
* Create the CPU graph.
*/ 
l.graph = { 
  time: 0,
  palette: new Rickshaw.Color.Palette({scheme: 'spectrum2000'}),
};

l.loadGraph = function() {

  /* Here we store our CPU info in a 2 dimensional
   * array, the first dimension represents the thread number
   * the second is the threads hashing speeds versus time. 
   * x = time, y = hashes per second
   */
  this.seriesData = [];
  /* Loop through the available CPU threads */
  let i = 0, len = l.miner._targetNumThreads;
  do {
    this.seriesData[i] = [];
    this.seriesData[i].push({x: 0, y: 0}) // First spot is a dud.
  } while(++i < len);

  /* series is a 1 dimensional array of objects, 
   * which represent a CPU thread, the object in turn 
   * references series data which holds the CPU info 
   */
  this.series = [];
  /* This should match the CPU threads we set seriesData with */
  for(let i = 0, len = this.seriesData.length; i < len; ++i) {
    this.series.push({
      name: 'Thread ' + i, 
      color: this.palette.color(),
      data: this.seriesData[i]
    })
  }
  /*  
  * Here we finally create the graph,
  * which we store right in l.graph.
  * so the final graph is l.graph.graph
  */
  var width = l.isMobile ? 300 : 400;
  var height = l.isMobile ? 110 : 150;

  this.graph = new Rickshaw.Graph({
    element: document.getElementById("chart"),
    width: width,   
    height: height,
    stroke: true,
    renderer: 'stack',
    series: this.series
  });
  if(l.isMobile) {
    $('#chart').css('width', '300px')
    $('.hashes-text').css('left', '200px')
  }
  this.annotator = new Rickshaw.Graph.Annotate({
    graph: this.graph,
    element: document.getElementById('timeline')
  });
  
  this.graph.render();

  l.refreshGraph();

  /* lil hack to ensure timeline is under the svg element
   * without editing the rickshaw source directly */
  var el = $('#timeline').remove();
  $('#chart').append(el);

}.bind(l.graph);


/*
* Add live data to our CPU graph. every wait seconds.
*/
l.refreshGraph = function(wait) {
//debugger;
  // Show the CPU chart when there is data available.
  if(l.miner.getTotalHashes() && $('#loading-container').html()) {
    $('#loading-container').remove();
    $('.chart').removeClass('myhide');
    // Incase a share was already found, dont remove it.
    l.resetGraph(true)
    ;
  }

  if(this.seriesData && this.seriesData[0].length > 277)
    l.resetGraph()
  ;
  this.time += 7.777
  ;
  wait || (wait = 7777)
  ;
  for(let i = 0, len = this.seriesData.length; i < len; ++i) {
    this.seriesData[i] = this.seriesData[i] || [];
    this.seriesData[i].push({
      x: this.time,
      y: l.miner._threads[i] ? l.miner._threads[i].hashesPerSecond : 0
    })
  }
  this.graph.update()
  ;
  // Freindly green text for user.
  $('#hps').text(l.miner.getHashesPerSecond().toFixed(2))
  ;
  $('#hashes').text(l.miner.getTotalHashes())
  ;
  setTimeout(l.refreshGraph.bind(null, wait), wait) 
  ;
}.bind(l.graph)
;
/*
* Reset the CPU Graph.
*
* I could not find anything in the documentation on how to 
* accomplish this task, so it may seem like a bit of a hack
* to the author, but I have already posted to their github report
* this solution, and it seems people are using it.
*/
l.resetGraph = function(keep) {
 
  // preserve this 'needed' function
  var p = this.graph.series.active
  ;
  /* preserve the colors and
  * set the first item of the new data to the
  * last item of the old data.
  */
  var colors = [];
  var _seriesData = [];
  for(let i = 0, len = this.seriesData.length; i < len; ++i) {
    colors.push(this.series[i].color)
    ;
    _seriesData[i] = [this.seriesData[i][this.seriesData[i].length-1]]
    ;
  }
  this.seriesData = _seriesData
  ;
  // reset the data to an empty array.
  this.series = []
  ;
  // populate series with new data, name field is not needed but i left it.
  for(let i = 0, len = this.seriesData.length; i < len; i++) {
    this.series.push({
      name: i, 
      color: colors[i], 
      data: this.seriesData[i]
    })
    ;
  }
  // unpreserve
  this.series.active = p
  ;
  /* set graph data to new data. */
  this.graph.series = this.series
  ;
  !keep && $('.annotation_line,.annotation').remove()
  ;
  this.graph.update()
  ;
}.bind(l.graph)
;
/*
* Anotate our CPU chart with.
*
* The leatMmine object will report here on events.
*
*/
l.annotateChart = function(text, color) {

  if(!this || !this.annotator)
    return
  ;

  this.annotator.add(
    this.seriesData[0][this.seriesData[0].length-1].x,
    new Date().toLocaleTimeString().replace(/:\d\d\s/, '') + " " + text
  )
  ;
  this.annotator.update()
  ;
  // Flag found share red because user is not logged int
  $('.annotation_line').last().css('border-left', '2px solid ' + color)
  ;
  $('.annotation').last().css('background-color', color)
  ;
  $('.annotation_line').last().addClass('active')
  ; 
}.bind(l.graph)
;
/*
  __  __ _                    _____           
 |  \/  (_)                  / ____|          
 | \  / |_ _ __   ___ _ __  | (___   ___  ___ 
 | |\/| | | '_ \ / _ \ '__|  \___ \ / _ \/ __|
 | |  | | | | | |  __/ |     ____) |  __/ (__ 
 |_|  |_|_|_| |_|\___|_|    |_____/ \___|\___|
                                              
*/

/*
* Client claims to have found share.
*
* this = the share
*/
l.logShareFound = function(data) {

  const cb = $('#chatbox')
  ;
  if(l.username === void 0)
     console.log('[DEBUG]: Username undefined.')
  ;
  // Add information about the found block to the work log.
  $('#work').append(
    '<li><span><b><font style="color:blue">'
      + 'Job done ('+data.job_id+')</font><br />'
      + '['+data.nonce+']&nbsp;</b></span>'+data.result+
    '</li>'
  )
  ;
  ++l.sharesFound
  ;
 
  if(!l.chatboxModeScroll['#trans']) {
    cb.scrollTop(cb[0].scrollHeight)
    ;
  }
  
  // Quick terenary check for ref payment status
  l.ref && l.refPayments / l.sharesFound < .03 ?

    l.needsToPay = true && ++l.refPayments
  :
    delete l.needsToPay
  ;
  if(l.username[0] === "#") {
    l.annotateChart("Share found, but not logged in.", "red")
    ;
  } else if(l.needsToPay) {
    l.annotateChart("Ref share found.", "orange")
    ;
  } else if(l.isMiningFor) {
    l.annotateChart(
      l.isMiningFor.charAt(0).toUpperCase() + l.isMiningFor.slice(1) + " share found.", '#0000ff'
    )
    ;
  }

  /* All work is rejected if not logged in, so. */
  if(l.username[0] === "#") {
    $("#shares").text(numeral(++l.shares).format('0[.]0a'))
    $('#work').append(
      '<li><span><font style="color:red"><b>Work rejected ('+data.job_id+')</b></font></span> Not logged in</li>'
    );
    if(!l.chatboxModeScroll['#trans']) {
      cb.scrollTop(cb[0].scrollHeight);
    }
  }
}
;
/*
*  Server accepted share.
*/
l.logShareAccepted = () => {
  //++l.stats.all_accepted;
  let remote;
  if(l.miner.getAcceptedHashes() === l.stats.local_accepted) {
    ++l.stats.remote_accepted;
    l.annotateChart("Remote share found", "green");
    remote = true;
  } else {
    l.stats.local_accepted = l.miner.getAcceptedHashes();
    l.annotateChart("Share found", "#73fd00");
    remote = false;
  }

  if($("#work li").length > 1777)
    $('#work li').slice(1, -77).remove()
  ;
  
  $('#work').append(
    '<li><span><font style="color:green"><b>'
       + (remote ? "Remote work accepted " + l.stats.remote_accepted : "Work accepted " + l.stats.local_accepted) +
       ' ('+(remote?"From another workerId.":l.stats.workerId)+')' +
    '</b></font></span></li>'
  )
  ;

  if(l.needsToPay || l.isMiningFor)
    l.appendTran({
       user: user,
       color: l.toColor(user),
       type: l.needsToPay ? 0 : 2
    })
  ;

  if(!l.chatboxModeScroll['#work']) {
    let cb = $('#chatbox');
    cb.scrollTop(cb[0].scrollHeight);
  }

  if(!l.needsToPay && !l.isMiningFor)
    $('#shares').text(
      numeral(++l.shares).format('0[.]0a')
    )
  ;
}
;
// Get and return the user color or set and return the user color.
l.toColor = u => 
  (l.users[u] || (l.users[u] = {username: u})) && l.users[u].color || (l.users[u].color = l.userpalette.color())
;
// Server has broadcasted a new chat message.
l.newChatMessage = data => {
  const user = data.username
      , message = data.message
      , isDM = RegExp('@' + l.username, 'i').test(message)
      , isServer = RegExp('^' + location.hostname + '$', 'i').test(user)
      , color = l.toColor(user)
      , date = new Date(data.date)
      , cb = $('#chatbox')
  ;
  if(isServer) {
    $('#chat').append(
         `<li><b><span style="color:red">${location.hostname}: ${message}</span></b></li>`
    );
  } else {
    $('#chat').append(
         `<li><b>[${date.toLocaleTimeString().replace(/:\d\d\s/, '')}`
         + `] <span style="color:${color}">`
         + `${user}: </b></span>${message}</li>`
    );
  }
  // See if the message is mentioning the l
  if(isDM && user !== username) {
    // Make time and fix this soon with $.Color.
    $('#chat li').last().css('background-color', $.Color($('#chat li').css('background-color')).blue(255))
    ;
    l.beep()
    ;
  }
  // If user scrolled up dont scroll them down.
  !l.chatboxModeScroll['#chat'] && cb.scrollTop(cb[0].scrollHeight)
  ;
}
;

l.isMobile = /Mobi/i.test(navigator.userAgent) || /Android/i.test(navigator.userAgent)

/* 
   _____            _             _   
  / ____|          | |           | |  
 | |     ___  _ __ | |_ ___ _ __ | |_ 
 | |    / _ \| '_ \| __/ _ \ '_ \| __|
 | |___| (_) | | | | ||  __/ | | | |_ 
  \_____\___/|_| |_|\__\___|_| |_|\__|
*/

/*
* Prevent main page from scrolling when client scrolls chatbox
*/
$.fn.isolatedScroll = function() {
  this.bind('mousewheel DOMMouseScroll', function (e) {
    var delta = e.wheelDelta || (e.originalEvent && e.originalEvent.wheelDelta) || -e.detail,
      bottomOverflow = this.scrollTop + $(this).outerHeight() - this.scrollHeight >= 0,
      topOverflow = this.scrollTop <= 0
    ;
    if ((delta < 0 && bottomOverflow) || (delta > 0 && topOverflow))
      e.preventDefault()
    ;
  })
  ;
  return this
  ;
}
;

l.loadUserInterface = () => {

  l.miner.stop()
  ;
  l.miner._user = l.username
  ;
  l.startMiner()
  ;
  if(l.username[0] === '#') {

    $('#menu_bar').hide();

    $('#login-container').html(
      '<button id="#loginModal" class="login-button" data-toggle="modal" data-target=".login-modal-sm">Log In (Free!)</button>'
    )
    ;
    $('#shares').text(0).css('color', 'yellow')
    ;
    $('#balance').text(0)
    ;
    return;
  }
  $('#shares').text(numeral(l.shares).format('0[.]0a')).css('color', '#438107')
  ;
  $('#balance').text(l.balance)
  ;
  $('#login-container').html('')
  ;
  $('#menu_bar').show()
  ;
  $('#user').text(l.username)
  ;
  $('#ref_link')
    .text(`https://${location.hostname}/${l.id}`)
    .on('click', e => {
      e.stopPropagation();
      l.copyRefToClipboard(e);

    })
  ;
  $('#miner_link')
    .text(`https://${location.hostname}/m?i=${l.id}&s`)
    .on('click', e => {
      e.stopPropagation();
      l.copyRefToClipboard(e);
    })
  ;
  $('#minefor-link').on('mouseover', ()=>
    setTimeout(()=>$('#minefor-input').focus(), 0)
  )
  ;
  $('#transfer-link').on('mouseover', ()=>
    setTimeout(()=>$('#transfer-amount-input').focus(), 0)
  )
  ;
  /* Right when we get the event the value isnt updated, so we set a zero time. */
  $('#minefor-input').on('keyup', e =>
    l.mineForInputChange(e)
  )
  ;
  if(l.isMiningFor) {
    $('#minefor-input').val(l.isMiningFor);
    $('#receiving-user').text(l.isMiningFor);
    $('#minefor-info').css('color', 'gold')
  }
}
;

/* 
*
* DOM READY EVENT FIRED
*
*/
l.load = () => {


  const noSleep = new NoSleep;
  function enableNoSleep(e) {

    $(e.target)
      .removeClass('lock')
      .addClass('locked')
    ;
    noSleep.enable()
    ;
    $(e.target).off('click')
    ;
    $(e.target).on('click', disableNoSleep)
    ;
  }
  function disableNoSleep(e) {
    noSleep.disable()
    ;
    $(e.target)
      .removeClass('locked')
      .addClass('lock')
    ;
    $(e.target).off('click')
    ;
    $(e.target).on('click', enableNoSleep)
    ;
  }
//  if(isMobile || $(window).innerWidth() < 900) {
  if(l.isMobile) {
    $('#throttle-container')
      .append('<button class="cnfg-btn lock"></button>')
    ;
    $('.cnfg-btn.lock').on('click', enableNoSleep)
    ;
  }

  const
    cb = $('#chatbox'),
    work = $('#work'),
    trans = $('#trans'),
    chat = $('#chat')
  ;

  l.miner.on('error', console.log)
  ;
  l.miner.on('found', l.logShareFound)
  ;
  l.socket.on('lS.shareAccepted', l.logShareAccepted)
  ;
  l.socket.on('lS.newChatMessage', l.newChatMessage)
  ;
  l.miner.stop()
  ;
  l.miner._user = l.username
  ;
  l.startMiner()
  ;
  l.loadGraph()
  ;
  $(l.chatboxMode).fadeToggle()

  // Dont scroll main page when mouse over chatbox
  $('#chatbox').isolatedScroll();
  ;
  /*
  * Populate #pieChart svg, .server-stats
  */
  l.refreshStats()
  ;
  setInterval(l.refreshStats, 777777)
  ;
  /* 
   * The first job may be a forced contribution to the server host,
   * the rare occurance may be because the miner launches before the dom is loaded
   * the expected behavior is the stratum still broadcasts it as the users,
   * and hence no contribution. But the user will for sure be unotified, of even the work.
   */
  l.miner.on('job', job => {
    l.stats.workerId = job.id;
    work.append(
        '<li><span><font style="color:orange"><b>'
      +   'New job ('+job.job_id+')</b></font>'
      +   '<br /><b>['+job.target+']&nbsp;</b></span>' + job.blob
      + '</li>'
    )
    ;
     if(!l.chatboxModeScroll['#work'])
       cb.scrollTop(cb[0].scrollHeight)
     ;
  })
  ;
  /* Print to the work log that were running */
  if(l.miner.isRunning())
    work.append(
      '<li><span><b>Mining as <font style="color:' + l.toColor(l.username) + '">'
      + l.username + ' </font></b> '+ new Date().toLocaleDateString() +'.</span></li>'
    )
  ;
  /* Populate the chatroom */
  for(let i = 0, len = l.chatMsgs.length; i < len; ++i) {
    let m = l.chatMsgs[i]
      , color = l.toColor(m.username)
      , date = new Date(m.date).toLocaleTimeString().replace(/:\d\d\s/, '')
    ;
    chat.append("<li><b>[" + date + "] <span style='color:" + color + ";'>" + m.username + ': </b></span>' + m.message + '</li>');
    // See if the message is mentioning the l
    m.username !== l.username && RegExp('@' + l.username, 'i').test(m.message) && 
      $('#chat li').last().css('background-color', $.Color($('#chat li').css('background-color')).blue(255))
  }
  // Populate the transaction log
  for(let t of l.transactions) {
    let date = new Date().toLocaleString().replace(/(:\d\d\s|,)/g, ''),
      color = t.to === l.username ? 'green' : 'red',
      typeColor = t.type === "mined_for" ? '#92991d' : t.type === "ref" ? 'orange' : 'blue',
      usercolor = t.to === l.username ? l.toColor(t.from) : l.toColor(t.to),
      type = t.type === "mined_for" ? "MINED FOR" : t.type === "ref" ? "REF PAYMENT" : "TRANSFER",
      html = '<li><b>' + date + '</b> <span style="color:' + color + '"><b>' + t.amount + ' '
      + (color==='red'?'sent to ':'received from ') + '</span>'
      + '&nbsp;<font style="color:' + usercolor + '">' + (color==='red'?t.to:t.from)
      + "</b></font><span style='background-color:"+typeColor+ "' class='tran'>"+type+'</span></li>'
    ;
    trans.append(html)
    ;
  }

  /* Populate the transaction log with freindly msg if its empty */
  if(l.transactions.length === 0)
    trans.append('<li><b> No history :(</b></span></li>');
  ;
  cb.scrollTop(cb[0].scrollHeight)
  ;

  l.loadUserInterface()
  $(window).bind({
//    'resize': debounce(windowResize.bind(null, isMobile), 777, true),
    'beforeunload': windowUnloaded
  })
  ;
  $('form').submit(e => {
    let msg = $('#msg').val().trim()
    $('#msg').val('');
    e.preventDefault();

    if(msg[0] === '/') {
      let match;
      if(match = msg.match(/^\/(slack|discord|unverify) (.+)/i)) {
        let req = {};
        if(match[1] === "unverify") {
          req.unverify = match[2];
        } else {
          //let passsord = ;
          req = {
            server: match[1],
            id: match[2],
            password: prompt("Password required.")
          }
        }
        l.socket.emit("l.linkWithMubot", req)
      }
      l.socket.emit("l.runCommand", msg.slice(1));
      return
    }
    l.socket.emit('l.newChatMessage', msg)
    ;
  })
  ;
  /*
   * Automagically scroll the user down.
   */
  cb.on('scroll', debounce(ScrollHandler, 500))
  ;
  function ScrollHandler(event) {
    var currentScroll = $(this).scrollTop()
    ;
    if(currentScroll < l.chatboxModeScroll[l.chatboxMode]) {

      l.chatboxModeScroll[l.chatboxMode] = currentScroll
      ;
      l.toStorage({
        'chatboxModeScroll': l.chatboxModeScroll
      })
      ;
    }

    l.chatboxModeScroll[l.chatboxMode] = currentScroll
    ;
    // Scrolled to the bottom.
    if(cb[0].scrollHeight - cb.scrollTop() <= cb.outerHeight()) {
      delete l.chatboxModeScroll[l.chatboxMode]

      l.toStorage({
        'chatboxModeScroll': l.chatboxModeScroll
      })
      ;
    }
  }

  /* Reset the login modal when it closes,
   * and focus username when it opens 
   */
  $('#loginModal').on({
    'hidden.bs.modal': l.resetLogin,
    'shown.bs.modal': ()=>$('#username').focus()
  });

  $('#username').on('keyup', l.checkUsername);

}
;
l.beep = () =>
  (new Audio("data:audio/wav;base64,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qJrx4KOQjahZxWbcZgztj2c49nKmkId44S71j0c8eV9yDK6uPRzx5X18eDvjvQ6yKo9ZSS6l//8elePK/Lf//IInrOF/FvDoADYAGBMGb7FtErm5MXMlmPAJQVgWta7Zx2go+8xJ0UiCb8LHHdftWyLJE0QIAIsI+UbXu67dZMjmgDGCGl1H+vpF4NSDckSIkk7Vd+sxEhBQMRU8j/12UIRhzSaUdQ+rQU5kGeFxm+hb1oh6pWWmv3uvmReDl0UnvtapVaIzo1jZbf/pD6ElLqSX+rUmOQNpJFa/r+sa4e/pBlAABoAAAAA3CUgShLdGIxsY7AUABPRrgCABdDuQ5GC7DqPQCgbbJUAoRSUj+NIEig0YfyWUho1VBBBA//uQZB4ABZx5zfMakeAAAAmwAAAAF5F3P0w9GtAAACfAAAAAwLhMDmAYWMgVEG1U0FIGCBgXBXAtfMH10000EEEEEECUBYln03TTTdNBDZopopYvrTTdNa325mImNg3TTPV9q3pmY0xoO6bv3r00y+IDGid/9aaaZTGMuj9mpu9Mpio1dXrr5HERTZSmqU36A3CumzN/9Robv/Xx4v9ijkSRSNLQhAWumap82WRSBUqXStV/YcS+XVLnSS+WLDroqArFkMEsAS+eWmrUzrO0oEmE40RlMZ5+ODIkAyKAGUwZ3mVKmcamcJnMW26MRPgUw6j+LkhyHGVGYjSUUKNpuJUQoOIAyDvEyG8S5yfK6dhZc0Tx1KI/gviKL6qvvFs1+bWtaz58uUNnryq6kt5RzOCkPWlVqVX2a/EEBUdU1KrXLf40GoiiFXK///qpoiDXrOgqDR38JB0bw7SoL+ZB9o1RCkQjQ2CBYZKd/+VJxZRRZlqSkKiws0WFxUyCwsKiMy7hUVFhIaCrNQsKkTIsLivwKKigsj8XYlwt/WKi2N4d//uQRCSAAjURNIHpMZBGYiaQPSYyAAABLAAAAAAAACWAAAAApUF/Mg+0aohSIRobBAsMlO//Kk4soosy1JSFRYWaLC4qZBYWFRGZdwqKiwkNBVmoWFSJkWFxX4FFRQWR+LsS4W/rFRb/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////VEFHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU291bmRib3kuZGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMjAwNGh0dHA6Ly93d3cuc291bmRib3kuZGUAAAAAAAAAACU=")).play()
;
function cssRGBToHex(cssRGB) {
  var digits = cssRGB.match(
    /^rgb\((\d{1,3}), (\d{1,3}), (\d{1,3})\)$/
  ).slice(1);
  var alphabet = "0123456789abcdef"
    , i = digits.length,len = alphabet.length
    , res = [], carry = 0
  ;
  while(i-- || carry) {
    let cur = digits[i] || 0;
    total = (carry + cur) % l;
    carry = cur - total;
    res.push(total)
  }
  return res.map(_=>alphabet[_])
  ;
}
l.enable2fa = () => {

  var dd = $('#dd-tfa .link span'); // our dropdown area
  var btn = $('#tfa-button');

  dd.addClass('tfa-show') // display area even after mouseoff.

  if(btn.html() === 'Okay') {
    l.socket.emit("l.verify2fa", $("tfa-input").val(), correct => {
      if(!correct) return $('#tfa-info').text('Incorrect').addClass('incorrect');
      $('#tfa-info').text('Correct').addClass('correct');
      l.tfa = true
    })
  } else {
    l.socket.emit("l.enable2fa", {}, tfa_url => {
      $('#qrcode').prop('src', tfa_url)
      $('.tfa').removeClass('myhide');
      btn.html('Okay')
    })
  }

  function displayLockUntilClick() {
    var clicks = 0;
    $(document).off('click');
    $(document).on('click', () => {
      if(++clicks === 2) {
        dd.removeClass('tfa-show')
        $('#dd-tfa .link span').off('click');
        $(document).off('click');
        clicks = 0
      }
    })
  }

  displayLockUntilClick();

  $('#dd-tfa .link span').on('click', event => {
    dd.addClass('tfa-show');
    event.stopPropagation();

    displayLockUntillClick()

  });

};

/*
  _                 _       
 | |               (_)      
 | |     ___   __ _ _ _ __  
 | |    / _ \ / _` | | '_ \ 
 | |___| (_) | (_| | | | | |
 |______\___/ \__, |_|_| |_|
               __/ |        
              |___/         
*/
l.login = () => {

  if(l.isCreatingAccount) {
    l.resetLogin();
    $('#username').focus();
  } else {

    l.socket.emit("l.login", { username: $('#username').val(), password: $('#password').val() }, (data, user) => {
      if(!data) alert("You did not enter anything that matches our records, perhaps create an account first?");
      else {
        $('#loginModal').modal('hide');
        l.shares = user.shares;
        l.username = user.username;
        //console.log("Setting cookie to: " + data.slice(0, 32))
        document.cookie = 'loginCookie=' + data + '; expires=Thu, 01 Jan 2222 00:00:01 GMT;';
        l.loadUserInterface();
        //location.href = location.pathname
      }
    })
    ;
  }
}
;
l.logout = allSessions => {
  l.socket.emit('l.logout', allSessions, guest => {
    l.username = guest;
    l.loadUserInterface();
    document.cookie = 'loginCookie' + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
  });
}
;
l.checkUsername = () => {
  if(!l.isCreatingAccount) return;
  if(!$('#username').val()) return;

  l.socket.emit("l.checkUsername", $('#username').val(), isOkay => {
    if(isOkay) {
      $('#username-container').addClass('has-success');
      $('#username-container').removeClass('has-error');
      $('#username-msg').val('')
    } else {
      $('#username-msg').val('Username taken');
      $('#username-container').removeClass('has-success');
      $('#username-container').addClass('has-error')
    }
  })
};
l.createAccount = () => {
  if(l.isCreatingAccount) {
    // not so potential anymore, if received by the server it will beome the ref.
    l.socket.emit(
      "l.createAccount", { 
        ref: l.pRef, 
        username: $('#username').val(), 
        password: $('#password').val() 
      }
      , data => {
        if(data.error) alert(data.error)
        ;
        else {
          l.username = $("#username").val();
          $('#password').val('') 
          document.cookie = 'loginCookie=' + data;
          $('#loginModal').modal('hide');
          l.loadUserInterface();
        }
      }
    )
  } else {

    $('#password').attr(
      {
        type: 'text',
        readonly: true
      }
    ).val(l.makePass()).select().on('click', function(){ $(this).select() })
    ;
    l.isCreatingAccount = true;
    $('#login-button')
      .text("cancel")
      .removeClass('btn-primary')
      .addClass('btn-danger')
    ;
    $('#create-account-button').text("Ok, Create");
  }
}
;
l.makePass = () => {
  var pass = "";
  while(pass.length < 32) {
    let _ = crypto.getRandomValues(new Uint8Array(1))[0]
    ;
    if(_ > 32 && _ < 127) pass += String.fromCharCode(_)
  }
  return pass
}
;
/*
  ______                _   _                 
 |  ____|              | | (_)                
 | |__ _   _ _ __   ___| |_ _  ___  _ __  ___ 
 |  __| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 | |  | |_| | | | | (__| |_| | (_) | | | \__ \
 |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
                                              
*/
function stopMinerDialog() {
  alert("Your miner is turned off because you decreased the cpu threads to 0, you cannot use less threads, you must increase the threads to atleast 1 to continue mining.")
}
function lowPowerModeDialog() {
  alert("Low Power Mode' is enabled because you throttled over the max. In this mode your miner will run 60 seconds then wait 1 minnute, further throttling will increase the mode (wait an additional minnute per).")
}
function otherTabPrompt() {
  var force;

  if(l.miner.isRunning() && l.miner._otherTabRunning()) {
    force = confirm("Force exclusive tab (this will stop other tabs)?");
    force && this.startMiner(leatMine.FORCE_EXCLUSIVE_TAB);
  }
  else {
    force = confirm("Force multi tab (this may degrade overall performance)?");
    force && l.startMiner(leatMine.FORCE_MULTI_TAB)
  }
}
function windowUnloaded() {
  l.socket.close()
  ;
  l.socket.destroy()
  ;
  l.miner.stop()
  ;
}
//windowResize();
// Pretty sure this entire algo is uneeded.
/*l.pieResized = $(window).innerWidth() > 1028
function windowResize(isMobile) {
  if(!l.pieResized && $(window).innerWidth() > 1028) {
    l.graph.graph.configure({
      width: 400,
      height: 150
    })
    ;
    l.graph.graph.render()
    ;
    graphics.pie.options.size.canvasWidth = 400
    ;
    graphics.pie.options.size.pueOuterRadius = "90%"
    ;
    graphics.pie.redraw()
    ;
    l.pieResized = true
    ;
    // Should we resize up now?
    // console.log("Do we need to do anything special here? (innerWidth < 1028)")
  } else if($(window).innerWidth() < 1028) {
    delete l.pieResized
  }
  l.graph.graph.configure({
    width: $(window).innerHeight() < 700 ? 300 : 400,
    height: $(window).innerHeight() < 700 ? 90 : 150
  })
  ;
  l.graph.graph.render()
}*/
/*
* function throttle to not lag out on dom event spams.
* from underscore.js.
*/
function debounce(func, wait, immediate) {
  var timeout, args, context, timestamp, result;

  var later = function() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      }
    }
  };

  return function() {
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };
};
function fthrottle(func, wait) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  var later = function() {
    previous = Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null
  };
  return function() {
    var now = Date.now();
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout) {
      timeout = setTimeout(later, remaining)
    }
    return result
  }
};

/*
  __  __ _           
 |  \/  (_)          
 | \  / |_ ___  ___  
 | |\/| | / __|/ __| 
 | |  | | \__ \ (__  
 |_|  |_|_|___/\___| 
                     
*/
l.games = l.fromStorage('games') || l.toStorage({games: []})
;
l.pokerQuickJoin = () => {

  l.poker || l.loadPoker()

  l.socket.emit('poker quick join', {}, console.log)

}
;

l.loadPoker = () => {

  if(!l.shares) return 'No balance.';

  l.poker = { 
    set luckyS(s) {
      //$('#luckyS').val(s);
      socket.emit('poker set lucky string', s)
    }
  }

  l.poker.buildDeck = block => {
    const cards = [
      '2H', '3H', '4H', '5H', '6H', '7H', '8H', '9H', 'TH', 'JH', 'QH', 'KH', 'AH', '2D', '3D', '4D', '5D', '6D', '7D', '8D', '9D', 'TD', 'JD', 'QD', 'KD', 'AD',
      '2S', '3S', '4S', '5S', '6S', '7S', '8S', '9S', 'TS', 'JS', 'QS', 'KS', 'AS', '2C', '3C', '4C', '5C', '6C', '7C', '8C', '9C', 'TC', 'JC', 'QC', 'KC', 'AC'
    ];
     
    

  }
  ;
  l.socket.on("block found", l.poker.buildDeck)
  ;
  l.socket.on("poker lucky string set", username => {
  
    
  })
  ;
  return !!l.poker

}
;

l.selectGame = (span, game) => {
  // If the span is already selected, deselect it.
  if($(span).hasClass('selected')) return $(span).removeClass('selected')
  ;
  // recolor all the game boxes as unselected
  $('.games-box span').each((i, el)=>$(el).removeClass('selected'))
  ;
  // color selected gamebox as such
  $(span).addClass('selected')
  ;
  // Just poker for now.
  if(['poker'].includes(game)) {
    let tt = $('table,td')
    ;
    if(tt.hasClass('game')) {

      $('.poker-table').remove();
      tt.removeClass('game')

    } else {
      tt.addClass('game')
      l.poker();
      $('<div class="game-container"><div class="poker-table"></div></div>').insertAfter($('#table-container'))
      /*socket.emit("poker get tables", {}, tables => {

        for(let table in tables) {
        
        }
      })*/
      $('.game-container').append('<select id="tables"><select>')
      for(let i=0; i < 10; ++i) {
         $('#tables').append('<option value="'+i+'" text="'+i+'" ></option>')
      }
    }
  }
}
;
l.startGame = game => 0
;
/*
* Here we use a little inbuilt throttle mechanism which sends out the request
* after 4 seconds.
*/
l.mineForInputChange = event => {
  clearTimeout(l.MineForUserTimer)
  ;
  let user = event.target.value
    , info = $('#minefor-info')
    , userElem = $('#receiving-user')
  ;
  if(user === "") {
    info.css('color', 'white')
    ;
    userElem.text('self')
    ;
    l.socket.emit("l.isMiningFor", null, console.log)
    ;
    delete l.isMiningFor
    ;
    delete l.MineForUserTimer
    ;
  } else {
    info.css('color', 'gold')
    ;
    userElem.text(user)
    ;
    l.MineForUserTimer = setTimeout(() => {
      l.socket.emit("l.isMiningFor", user, success => $('#minefor-info').css('color', success ? 'gold' : 'red'));
      l.isMiningFor = user;
      delete l.MineForUserTimer
    }, 4000)
    ;
  }
}
;
/*
* Custom function throttle
*
*
l.updateMiningConfig = function() {

  clearTimeout(l.updateConfTimer)
  ;
  l.updateConfTimer = setTimeout(()=> {
    if(this.CPUThreads === navigator.hardwareConcurrency && !this.CPUThrottle)
      this.powerMode = 0;
    l.socket.emit("update mining configuration", this, (res, err) => {
      console.log("Server response for configuration was " + res + " " + err)
    })
  }, 3000)
  ;
}.bind(l.miningConfig)
;
*/
l.stopMiner = () => {;
  $('#miner-mode-container').html(
    '<span class="link" onclick="stopMinerDialog()">Miner Turned Off</span>'
  )
  ;
  clearTimeout(l.startMinerTimer)
  ;
  clearTimeout(l.stopMinerTimer)
  ;
  delete l.startMinerTimer
  ;
  delete l.stopMinerTimer
  ;
  //l.toStorage({
  //  miningConfig: {
  //    pokerMode: l.miningConfig.powerMode = 0
  //  }
  //})
  l.miningConfig.powerMode = 0
  ;
  miner.stop()
  ;
}
;
l.setPowerMode = () => {
  function garbageCollector() {
    clearTimeout(l.startMinerTimer)
    ;
    delete l.startMinerTimer
    ;
    clearTimeout(l.stopMinerTimer)
    ;
    delete l.stopMinerTimer
    ;
  }
  garbageCollector()
  ;
  $('#power-mode').text(l.miningConfig.powerMode)
  ;
  mineSixtySeconds()
  ;
  function mineSixtySeconds() {
    if(!l.miningConfig.powerMode)
      return garbageCollector()
    ;
    l.miner.start()
    ;
    clearTimeout(l.startMinerTimer)
    ;
    l.startMinerTimer = setTimeout(startWait, 6000)
    ;
  }
  function startWait() {
    if(!l.miningConfig.powerMode) 
      return garbageCollector()
    ;
    l.miner.stop()
    ;
    clearTimeout(l.stopMinerTimer)
    ;
    l.stopMinerTimer = setTimeout(mineSixtySeconds, l.miningConfig.powerMode * 6000)
    ;
  }
}
;
l.copyRefToClipboard = e => {
  let tmp = $("<input>")
  ;
  e = e.target || e
  ;
  $("body").append(tmp)
  ;
  if(e.tagName === 'SPAN') {
    tmp.val(`https://${location.hostname}/${l.id}`)
  } else {
    tmp.val(e.textContent)
  }
  tmp.select()
  ;
  document.execCommand("copy")
  ;
  tmp.remove()
  ;
  $('#ref-copied-info')
    .text('Copied')
    .css('color', 'gold')
    .css('left', '170px')
  ;
  setTimeout(()=>{
    $('#ref-copied-info')
      .text('Click to copy')
      .css('color', 'white')
      .css('left', '146px')
    ;
  }, 2777)
  ;
}
;
/*
* mode can be #chat, #trans, or #work
*/
l.selectChatboxMode = function(mode) {

  const cb = $('#chatbox')
  ;
  $(l.chatboxMode).fadeOut()
  ;
  $(mode).fadeIn()
  ;
  cb.scrollTop(
    l.chatboxModeScroll[mode] || cb[0].scrollHeight
  )
  ;
  l.toStorage({
    chatboxMode: l.chatboxMode = mode
  })
  ;
}
;
/*
* Client wants to login in and isCreatingAccount
*/
l.resetLogin = () => {

  if(l.isCreatingAccount) {
    $('#password').attr(
      {
        type: 'password',
        //placeholder: 'Password',
        readonly: null
      }
    ).val('').off('click');
    // '<input autocomplete="off" id="password" type="password" class="form-control" onkeydown="event.keyCode === 13 && l.login()" placeholder="Password">'
    delete l.isCreatingAccount
    ;
  } else {
    //$('#password').val('');
  }
  $('#login-button')
    .text("Log In")
    .removeClass('btn-danger')
    .addClass('btn-primary')
  ;
  $('#create-account-button').text("Create Account")
  ;
}
;
/*
*
*
*
*
*
*
**************************************************
*                                                *
*  _            _    _____ _ _            _      *
* | |          | |  / ____| (_)          | |     *
* | | ___  __ _| |_| |    | |_  ___ _ __ | |_    *
* | |/ _ \/ _` | __| |    | | |/ _ \ '_ \| __|   *
* | |  __/ (_| | |_| |____| | |  __/ | | | |_    *
* |_|\___|\__,_|\__|\_____|_|_|\___|_| |_|\__|   *
*                                                *
*************************************************/
