'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.argon2d = exports.argon2i = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _refNapi = require('ref-napi');

var _refNapi2 = _interopRequireDefault(_refNapi);

var _library = require('./library');

var _anyPromise = require('any-promise');

var _anyPromise2 = _interopRequireDefault(_anyPromise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ARGON2_OK = 0;
var ARGON2_VERIFY_MISMATCH = -35;

var defaultOptions = {
  timeCost: 3,
  memoryCost: 1 << 12,
  parallelism: 1,
  hashLength: 32
};

function parseArgs(_ref) {
  var _ref2 = _slicedToArray(_ref, 3),
      password = _ref2[0],
      salt = _ref2[1],
      _ref2$ = _ref2[2],
      options = _ref2$ === undefined ? {} : _ref2$;

  if (typeof password === 'string') {
    password = new Buffer(password);
  }
  options = Object.assign({}, defaultOptions, options);

  return [password, salt, options];
}

function variant(_hashRaw, hashEncoded, _verify) {
  return {
    hashRaw: function hashRaw() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _parseArgs = parseArgs(args),
          _parseArgs2 = _slicedToArray(_parseArgs, 3),
          password = _parseArgs2[0],
          salt = _parseArgs2[1],
          options = _parseArgs2[2];

      var timeCost = options.timeCost,
          memoryCost = options.memoryCost,
          parallelism = options.parallelism,
          hashLength = options.hashLength;

      var hashOutput = new Buffer(hashLength);
      var promise = new _anyPromise2.default(function (resolve, reject) {
        var resultHandler = function resultHandler(err, res) {
          if (err) {
            return reject(err);
          }
          if (res !== ARGON2_OK) {
            return reject(new Error((0, _library.argon2ErrorMessage)(res)));
          }
          return resolve(hashOutput);
        };
        _hashRaw.async(timeCost, memoryCost, parallelism, password, password.length, salt, salt.length, hashOutput, hashLength, resultHandler);
      });
      return promise;
    },
    hash: function hash() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var _parseArgs3 = parseArgs(args),
          _parseArgs4 = _slicedToArray(_parseArgs3, 3),
          password = _parseArgs4[0],
          salt = _parseArgs4[1],
          options = _parseArgs4[2];

      var timeCost = options.timeCost,
          memoryCost = options.memoryCost,
          parallelism = options.parallelism,
          hashLength = options.hashLength;

      var encodedSize = (0, _library.argon2Encodedlen)(timeCost, memoryCost, parallelism, salt.length, hashLength);
      var outputBuffer = new Buffer(encodedSize);
      var promise = new _anyPromise2.default(function (resolve, reject) {
        var resultHandler = function resultHandler(err, res) {
          if (err) {
            return reject(err);
          }
          if (res !== ARGON2_OK) {
            return reject(new Error((0, _library.argon2ErrorMessage)(res)));
          }
          return resolve(_refNapi2.default.readCString(outputBuffer, 0));
        };
        hashEncoded.async(timeCost, memoryCost, parallelism, password, password.length, salt, salt.length, hashLength, outputBuffer, outputBuffer.length, resultHandler);
      });
      return promise;
    },
    verify: function verify(encoded, password) {
      var encodedBuffer = _refNapi2.default.allocCString(encoded || '');
      var parsedPassword = password;
      if (typeof password === 'string') {
        parsedPassword = new Buffer(password);
      }
      var promise = new _anyPromise2.default(function (resolve, reject) {
        var resultHandler = function resultHandler(err, res) {
          if (err) {
            return reject(err);
          }
          if (res === ARGON2_OK) {
            return resolve(true);
          } else if (res === ARGON2_VERIFY_MISMATCH) {
            return resolve(false);
          } else {
            return reject(new Error((0, _library.argon2ErrorMessage)(res)));
          }
        };
        _verify.async(encodedBuffer, parsedPassword, parsedPassword.length, resultHandler);
      });
      return promise;
    }
  };
}

var argon2i = exports.argon2i = variant(_library.argon2iHashRaw, _library.argon2iHashEncoded, _library.argon2iVerify);
var argon2d = exports.argon2d = variant(_library.argon2dHashRaw, _library.argon2dHashEncoded, _library.argon2dVerify);